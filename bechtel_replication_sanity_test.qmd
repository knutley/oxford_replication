---
title: "Untitled"
format: html
---

```{r}
#| label: setup

library("tidyverse", include.only=c())
library("magrittr",include.only=c("%<>%","%>%"))
library("conflicted")
library("broom", include.only=c())

```

## Loading Replication Data

```{r}
#| label: replication_load

orig.df <- haven::read_dta("bechtel_original/bechtel_liesch_scheve_pnas.dta")
```

*Replication data loads successfully.*

## **Replication Check**

The key claim from the paper is on pg 3611:

`individuals who give to those who are poorer are generally not the same individuals who also take from others who are richer`

The primary quantitative summary supporting this result in the paper is Table 1, which summarizes the distribution of types:

`Frequencies of d-redistribution and a-redistribution types in the pooled sample and by country (weighted)`

The included replication file for this article "Replicate Results_Bechtel Liesch Scheve_PNAS.do" replicates Table 1, with the following code:

svyset \[pweight = weight\]

svy: tab dtype atype

svy: tab dtype atype if GE == 0

svy: tab dtype atype if GE == 1

**Note that the key variables, *dtype* and *atype* are pre-computed in the replication data file above, they are not computed from the data, nor does the replication code provide the functions to compute them.**

The type computation is described only textually, in the *Supplementary Appendix*, as follows [^1]:

[^1]: See the estimation function section for the full text.

`...  To derive individual-level sensitivities to a- and d-inequality, we estimate two auxiliary regressions for each respondent. To estimate d-sensitivity (the elasticity of redistribution behavior to disadvantageous inequality) we regress for each respondent the amount given on ΔPoorer using allobservations for which ΔPoorer ≥ 0 and multiply the estimated coefficient by -1. To estimate a- sensitivity (the elasticity of redistribution behavior to advantageous inequality), we regress for eachrespondent the amount given on ΔRicher using all observations for which ΔRicher ≥ 0. We use the estimated coefficients (d-sensitivity and a-sensitivity) to classify individuals’ redistribution types. ,,,`

**Note however that the replication data does not contain the elicited gift card amounts schedules for each recipient – so the type estimates cannot be replicated.**

```{r}
#| label: replication_view


colnames(orig.df)
```

*Fortunately, the replication data for figure 4, although it does not contain the original experiment responses, does contain sufficient data individuals to reconstruct the response schedule, and appears to preserve the same row numbers as the main data file – which will enable validation of the estimation code:*

```{r}
#| label: fig-4-data   

fig4.df <- haven::read_dta("bechtel_original/bechtel_liesch_scheve_pnas Fig. S4.dta")

fig4.df %>%
  dplyr::slice_head(n=10)
```

## **Estimation Function**

Using the synthetic data, we code sensitivity estimation based on the *Supplementary Information* description below:

`Coding of Types We estimate each respondent’s sensitivity to a- and d-inequality using their conditional redistribution behavior in combination with individual-level auxiliary regressions. The dependent variable is Given which measures the amount given (positive values) or taken in each of the proposed scenarios. Our independent variables are: ΔPoorer, which is the difference between the other respondent’s initial gift card value and the respondent’s own initial gift card value. The second independent variable is ΔRicher. This variable equals the difference between one’s own initial gift card value and the gift card value of other respondent. To derive individual-level sensitivities to a- and d-inequality, we estimate two auxiliary regressions for each respondent. To estimate d-sensitivity (the elasticity of redistribution behavior to disadvantageous inequality) we regress for each respondent the amount given on ΔPoorer using allobservations for which ΔPoorer ≥ 0 and multiply the estimated coefficient by -1. To estimate a- sensitivity (the elasticity of redistribution behavior to advantageous inequality), we regress for eachrespondent the amount given on ΔRicher using all observations for which ΔRicher ≥ 0. We use the estimated coefficients (d-sensitivity and a-sensitivity) to classify individuals’ redistribution types.`

`We use the following coding rule where “sensitivity” refers to the estimated coefficient: - Equalizer: .25 ≤ sensitivity < .75 - Non-Equalizer: -.25 ≤ sensitivity < .25 - Other: All remaining cases.`

```{r}

#| label: estimate types


estimate_sensitivies <- function(i_schedule) {

  # rules based data check: cannot give more than endowment
  #or receive more than total
  

  x.df <- i_schedule
  if (!is.data.frame(x.df)) {
    x.df <- x.df[[1]]
  }
  x.df  <- x.df %>%
     # " Given measures the amount given or taken in each of the proposed scenarios"
    dplyr::rowwise() %>%
    dplyr::mutate( 
    
      #"ΔPoorer, which is the difference between the other respondent’s initial gift card value and the respondent’s own initial gift card value"
      d_poorer = `other`-`endowment`,
      #ΔRicher. This variable equals the difference between one’s own initial gift card value and the gift card value of other respondent.:
      d_richer = `endowment` -`other`,
      # sanity_check -- check that gift/take amounts are possible
      d_valid_choice = ifelse(
        (`transfer_from` > endowment) || ( `transfer_from` < (-1*other)),
        FALSE,
        TRUE
      )
    ) %>%
    dplyr::ungroup()
  
  
  rv <- list()
  
  #
  #o estimate d-sensitivity (the elasticity of redistribution behavior to disadvantageous inequality) we regress for each respondent the amount given on ΔPoorer using all  observations for which ΔPoorer ≥ 0 and multiply the estimated coefficient by -1. 
  
 reg_poor <- x.df %>%
      dplyr::filter(d_poorer>=0 & d_valid_choice) %>%
      stats::lm(data = ., formula = transfer_from ~ d_poorer) %>% 
      summary() %>% 
      broom::tidy()
 
 rv["d_sensitivity_r"] <- 
   reg_poor %>% 
    dplyr::filter(term=="d_poorer") %>%
    pull(`estimate`) * -1
 
 
 #To estimate a- sensitivity (the elasticity of redistribution behavior to advantageous inequality), we regress for eachrespondent the amount given on ΔRicher using all observations for which ΔRicher ≥ 0. 
 
  reg_rich <- x.df %>%
      dplyr::filter(d_richer>=0 & d_valid_choice) %>%
      stats::lm(data = ., formula = transfer_from ~ d_richer) %>% 
      summary() %>% 
      broom::tidy()
  

  rv["a_sensitivity_r"] <- 
   reg_rich %>% 
    dplyr::filter(term=="d_richer") %>%
    pull(`estimate`) 
  
#We use the following coding rule where “sensitivity” refers to the estimated coefficient: - Equalizer: .25 ≤ sensitivity < .75 - Non-Equalizer: -.25 ≤ sensitivity < .25 - Other: All remaining cases.
  
   cat_label<-function(x) {
     dplyr::case_when(
              ((x >=.25) && (x< .75)) ~ "Equalizer"  ,
              ((x >= -.25) && (x < .25)) ~ "Non-Equalizer",
              .default = "Other"
            )
   }
  
  rv["d_sensitivity_cat_r"] <- 
   cat_label(rv[["d_sensitivity_r"]])
  
  
   rv["a_sensitivity_cat_r"] <- 
    cat_label(rv[["a_sensitivity_r"]])  
   
   as_tibble(rv)
  
}
```

*Validation using replication data*

```{r}

#| label:   validation




# applying the description of the data in the figure from the SI
#
# * page 8: share taken = taken / other 
# * page 8: share given = given / own 

# # NOTE: surprizingly, `taken` has a different semantic in this dataset then in the replication dataset above, and `given` has a different semantic in this dataset than in the sensitivity regression formula. 

# Defining a new variable: transfer_from , with consistent semantics
# transfer from := the amount transfered from the subject to recipient... i.e. the amount given when the subject chose  "give", 0 if the subject chose to do nothing,and -1* the amount taken when the subject chose  "take". This definition is  identical to 'given' as used in the d_ and a_sensitivity calculations


fig4.df %>% 
  dplyr::mutate(endowment= `IA1`, 
     #"ΔPoorer, which is the difference between the other respondent’s initial gift card value and the respondent’s own initial gift card value"

      other= `IA1` + `delta_poorer`,
     #The share taken is the amount taken divided by the other respondent’s endowment,
                given = -1*round(`endowment`  * `shareTaken`)
                %>% haven::zap_label(),
                taken = ( `shareTaken` *other) %>% 
                  haven::zap_label(),
                transfer_from = case_when(
                  `shareTaken` >0 ~ -taken,
                  `shareTaken` <0 ~ given,
                  `shareTaken` ==0  ~ 0
                  
                ) %>% haven::zap_label()
                )%>%
  dplyr::select(`ID`,`endowment`,`other`,`transfer_from`) %>%
  tidyr::nest(sched=-`ID`) -> sched.df




orig.df  %>% dplyr::bind_cols(sched.df) -> 
  orig_extend.df
orig_extend.df[[1,"sched"]]


orig_extend.df[[1,"sched"]] %>% estimate_sensitivies()


orig_extend.df %>% 
  dplyr::slice_sample(n=50) %>%
  dplyr::rowwise() %>%
  dplyr::mutate(est_sensitivities = list(estimate_sensitivies(sched))) %>%
  dplyr::ungroup() %>%
  tidyr::unnest(est_sensitivities) %>%
  dplyr::select(dplyr::contains("sensitivity"), `atype`, `dtype`) %>%
  dplyr::mutate(dplyr::across(
    c(d_sensitivity, d_sensitivity_r, a_sensitivity, a_sensitivity_r), ~ round(.x, digits=2))
    )%>%
  dplyr::relocate(d_sensitivity, d_sensitivity_r, a_sensitivity, a_sensitivity_r) 
```

Visual comparison of sample of 50 rows confirmsthat estimation is identical to 2 sig decimals

## Cleaning Synthetic Output

The raw output is currently untidy, so we'll tidy it up first, and then use the tidied inputs for the estimation function.

**As it turns out the answers to the schedule is not a set of answers to repeated question, but a single answer to the prompt, and not possible to parse reliably automatically. Refactored as multiple prompts,**

```{r}
#| label: experiment_load

# read data from  output of prompt v1.1

t2m_output_raw.df <- readxl::read_excel(
  "t2m_synthetic_respondents_pilot/bechtel_etal2018_output_1_20251230T160911Z.xlsx"
  )

colnames(t2m_output_raw.df)

cat("examples of schedule reponses\n\n")

t2m_output_raw.df %>% 
  dplyr::pull(`response_schedule1.response`)

```

Note that (a) some responses are invalid. All responses should be in \[0, endowment\], we see negative responses, non-numeric responses. (b) pseudo-facilitator responses are interleaved...

```{r}
#| label: experiment_clean

# faclitator is not used in the game, but required -- filter this
# game only has one round in reality, drop 2nd

#t2m_std.df <- 
  
  extract_cat_greedy <- function(x) {
    x %>%
    stringr::str_to_lower() %>%
    stringr::str_extract(
         '\\s*(give|take|do nothing).*', group=1)
  }
  
  extract_val_greedy <- function(x) {
    x %>% 
      stringr::str_to_lower() %>%
      stringr::str_extract(
         '(\\-?\\d+)', group=1) %>%
      as.numeric()
  }
  
  calc_transfer_from <- function(value,cat) {
    adj <- 
       dplyr::case_match( cat,
            "give" ~ 1,
            "take" ~ -1,
            "do nothing" ~ 0,
            NA ~ 1,
            .default = 1
          )
     rv <- adj * value
     rv
    
  }

  
  t2m_output_raw.df %>%
    dplyr::filter( # filter facilitator
      !stringr::str_detect(stringr::str_to_lower(role),"facilitator")) %>%
      dplyr::select(`ID`, # drop metadata columns
                  `treatment`,
                   dplyr::matches("\\.response[\\.]?"))  %>% 
       dplyr::mutate( # derive parameters from treatment 
         phase1_endowment = 
             stringr::str_extract(`treatment`,
                           '.*endowment_(\\d+)_.*', group=1) %>%
                            as.numeric(),
         phase1_other = # budget in experiment is $100, so can derive other level
             100 - phase1_endowment
         ) %>%
      # extract first phase choice
      dplyr::mutate( phase1_transfer_from =
                calc_transfer_from( 
                  value = extract_val_greedy(`give_value.response`), 
                 cat =  extract_cat_greedy(`categorical_choice.response`))) %>%
      #extract second phase schedule elicitation
      dplyr::rowwise() %>%
      dplyr::mutate(
        dplyr::across( dplyr::matches("schedule") , 
                      ~ calc_transfer_from(value=extract_val_greedy(.x),
                                          cat = extract_cat_greedy(.x))
                      , .names="{.col}_clean"  )
      ) %>%
    ungroup()  -> t2m_clean.df
  
  # nest into response schedule form, based on known treatment offer schedule
  
  other_sched <- c(5,15,25,50,75,85,95)
  
  
  build_sched <- function(e, o, t, ps) {
    rv <- ps
    other_sched <- c(5,15,25,50,75,85,95)
    rv <- rv %>%
      mutate(other = other_sched[schedule_number],
             endowment = e) %>%
      dplyr::bind_rows(tibble(endowment=e, other=o, transfer_from=t)) %>%
      dplyr::distinct() %>%
      select(-schedule_number)
  }
  
  t2m_clean.df %>% 
    dplyr::select(`ID`,
                  dplyr::starts_with("phase1_"), 
                  dplyr::ends_with("_clean")) %>%
    tidyr::pivot_longer(cols= dplyr::ends_with("_clean"),
                        values_to = "transfer_from") %>%
    mutate(schedule_number=str_extract(`name`,
                           '.*schedule(\\d+),*', group=1) %>% as.numeric()) %>%
    dplyr::select(-name) %>%
    tidyr::nest(pre_sched=c(`schedule_number`, `transfer_from`)) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(sched=list(build_sched(e=`phase1_endowment`, 
                                    o=`phase1_other`,
                                    t=`phase1_transfer_from`,
                                    ps=`pre_sched`))) %>%
    dplyr::ungroup() %>%
    dplyr::select(`ID`,`sched`) -> t2m_std.df

```

## Estimating coefficients for synthetic output

Finally, we'll run the type estimation using synthetic data from the T2M output.

Apply *estimate_sentitivities* to cleaned output data

```{r}
t2m_std.df %>%
  dplyr::rowwise() %>%
  dplyr::mutate(est_sensitivities = list(estimate_sensitivies(sched))) %>%
  dplyr::ungroup() %>%
  tidyr::unnest(est_sensitivities) -> t2m_est.df

t2m_est.df %>% 
 # dplyr::select(-sched) %>%
  gt::gt()
```

Success! (plausibly)
